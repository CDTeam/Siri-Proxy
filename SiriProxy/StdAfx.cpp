// Copyright (c) 2011,cd-team.org.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
#include "StdAfx.h"
#include "resource.h"
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>

#define  SIO_RCVALL  IOC_IN | IOC_VENDOR | 1
#define  SIO_RCVALL_MCAST  IOC_IN | IOC_VENDOR | 2
#define  SIO_RCVALL_IGMPMCAST  IOC_IN | IOC_VENDOR | 3
#define  SIO_KEEPALIVE_VALS  IOC_IN | IOC_VENDOR | 4
#pragma comment(lib,"Ws2_32.lib.")
typedef void (*FuncMemFree)(void *);
FuncMemFree pfnPlistFreeMem=NULL;

string iPhone4s_header_tmpl;

void ConvertEndian64(void* lpMem )
{
	unsigned char * p = (unsigned char*)lpMem;
	p[0] = p[0] ^ p[7];
	p[7] = p[0] ^ p[7];
	p[0] = p[0] ^ p[7];

	p[1] = p[1] ^ p[6];
	p[6] = p[1] ^ p[6];
	p[1] = p[1] ^ p[6];

	p[2] = p[2] ^ p[5];
	p[5] = p[2] ^ p[5];
	p[2] = p[2] ^ p[5];

	p[3] = p[3] ^ p[4];
	p[4] = p[3] ^ p[4];
	p[3] = p[3] ^ p[4];
}

void ConvertEndian32(void* lpMem )
{
	unsigned char * p = (unsigned char*)lpMem;
	p[0] = p[0] ^ p[3];
	p[3] = p[0] ^ p[3];
	p[0] = p[0] ^ p[3];
	p[1] = p[1] ^ p[2];
	p[2] = p[1] ^ p[2];
	p[1] = p[1] ^ p[2];
}

void ConvertEndian16(void* lpMem )
{
	unsigned char * p = (unsigned char*)lpMem;
	p[0] = p[0] ^ p[1];
	p[1] = p[0] ^ p[1];
	p[0] = p[0] ^ p[1];
}

void InitPhone4sHeaderTmpl()
{
	char path[260]={0};
	GetModuleFileNameA(NULL,path,260);
	HMODULE hMod=GetModuleHandleA("SiriProxy.dll");
	HRSRC hRes=FindResourceA(hMod,MAKEINTRESOURCEA(IDR_HEADER_PHONE4S),"HEADER");
	DWORD dwSize=SizeofResource(hMod,hRes);
	HGLOBAL hGlobal=LoadResource(hMod,hRes);
	LPVOID lpRes=LockResource(hGlobal);
	char* buffer=(char*)lpRes;
	iPhone4s_header_tmpl.append(buffer,dwSize);
	FreeResource(hGlobal);
}

std::wstring UTF8ToUTF16(const std::string &utf8Str)
{
	int u16Len = ::MultiByteToWideChar(CP_UTF8, NULL,utf8Str.c_str(),(int)utf8Str.size(), NULL, 0);
	wchar_t* wstrBuf = new wchar_t[u16Len + 1];
	::MultiByteToWideChar(CP_UTF8, NULL, utf8Str.c_str(),(int)utf8Str.size(), wstrBuf, u16Len);
	wstrBuf[u16Len] =L'\0';
	std::wstring wStr = wstrBuf;
	delete [] wstrBuf;
	return wStr;
}

std::string Utf16ToUtf8( const wstring& utf16Str )
{
	int u8Len = ::WideCharToMultiByte(CP_UTF8, NULL, utf16Str.c_str(), (int)utf16Str.size(), NULL, 0, NULL, NULL);
	char* strBuf = new char[u8Len + 1];
	::WideCharToMultiByte(CP_UTF8, NULL, utf16Str.c_str(), (int)utf16Str.size(), strBuf, u8Len, NULL, NULL);
	strBuf[u8Len] = '\0';
	std::string str = strBuf;
	delete [] strBuf;
	return str;
}

Poco::DateTime time_t_to_localtime( const time_t& t )
{
	std::tm then = *std::localtime(&t);
	DateTime dt=DateTime((then.tm_year + 1900),
		(then.tm_mon + 1),
		then.tm_mday,
		then.tm_hour,
		then.tm_min,
		then.tm_sec,
		0,
		0);
	return dt;
}

std::string format_time_t_string( const time_t& t )
{
	DateTime dt=time_t_to_localtime(t);
	return DateTimeFormatter::format(dt,DateTimeFormat::SORTABLE_FORMAT);
}

bool SetSocketKeepAlive( SOCKET s )
{
	TCP_KEEPALIVE_ARG inKeepAlive = {0};
	unsigned long ulInLen = sizeof(TCP_KEEPALIVE_ARG);
	TCP_KEEPALIVE_ARG outKeepAlive = {0};
	unsigned long ulOutLen = sizeof(TCP_KEEPALIVE_ARG);

	unsigned long ulBytesReturn = 0;

	//设置socket的keep alive为10秒，并且发送次数为3次 
	inKeepAlive.onoff = 1;
	inKeepAlive.keepaliveinterval = 10000;
	inKeepAlive.keepalivetime = 3; 

	//为选定的SOCKET设置Keep Alive，成功后SOCKET可通过Keep Alive自动检测连接是否断开 
	
	int code= WSAIoctl(s, SIO_KEEPALIVE_VALS, (LPVOID)&inKeepAlive, ulInLen, (LPVOID)&outKeepAlive, ulOutLen, &ulBytesReturn, NULL, NULL);
	return code!=SOCKET_ERROR;
}
