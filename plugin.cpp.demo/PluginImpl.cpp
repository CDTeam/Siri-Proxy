// Copyright (c) 2011,cd-team.org.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include "PluginImpl.h"
#include "libplist.h"
#include <string>
#include <ctype.h>
#include <algorithm>
using namespace std;

CommandCallResult* __stdcall ProcessCommandCall(PlistPackageArgs* args);
void			   __stdcall PluginInfoFree(PluginInfo* p );
bool			   __stdcall InitPluginModule();
void			   __stdcall UnInitPluginModule();
void			   __stdcall FreeCommandCallResult(CommandCallResult* p);

extern PluginInfo* PluginInitMain()
{
	PluginInfo* info=new PluginInfo();
	memset(info,0,sizeof(PluginInfo));
	char* pluginId="D447BB43-B034-4a59-8EC1-81310D9FE714";
	char* pluginName="the siri proxy plugin demo implements by c plus plus language";
	size_t len=strlen(pluginId);
	memcpy(&info->PluginId[0],pluginId,len);
	info->PluginId[len]='\0';
	len=strlen(pluginName);
	info->PluginName=new char[len+1];
	strcpy(info->PluginName,pluginName);
	info->OnCommandCall=ProcessCommandCall;
	info->InitPluginModule=InitPluginModule;
	info->UnInitPluginModule=UnInitPluginModule;
	info->PluginInfoFree=PluginInfoFree;

	char* tmp="hello";
	info->CommandText=new char[strlen(tmp)+1];
	strcpy(info->CommandText,tmp);
	tmp="fee?.+";
	info->CommandMatchPattern=new char[strlen(tmp)+1];
	strcpy(info->CommandMatchPattern,tmp);
	return info;
}

CommandCallResult* __stdcall ProcessCommandCall(PlistPackageArgs* args)
{
	CommandCallResult* p=new CommandCallResult();
	memset(p,0,sizeof(CommandCallResult));
	p->FreeCommandCallResult=FreeCommandCallResult;
	string s="catch the command text:";
	s+=args->sendText;
	p->result_text=new char[s.size()+1];
	strcpy(p->result_text,s.c_str());
	p->type=RESULT_TEXT;
	return p;
}

void __stdcall FreeCommandCallResult(CommandCallResult* p)
{
	if(p->result_text!=NULL)
		delete[] p->result_text;
	delete p;
}

void __stdcall PluginInfoFree(PluginInfo* p )
{
	if(p->PluginName!=NULL)
	{
		delete[] p->PluginName;
	}
	if(p->CommandText!=NULL)
	{
		delete[] p->CommandText;
	}
	if(p->CommandMatchPattern!=NULL)
	{
		delete[] p->CommandMatchPattern;
	}
	delete p;
}

bool __stdcall InitPluginModule()
{
	return true;
}

void __stdcall UnInitPluginModule()
{
	return;
}