// Copyright (c) 2011,cd-team.org.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
#include "StdAfx.h"
#include "DbHelpMySQL.h"
#include "SiriTokenProvider.h"
#include <Poco/Format.h>
#include <Poco/Data/Common.h>
#include <Poco/Data/BLOB.h>
#include <Poco/Data/RecordSet.h>
#include <Poco/Data/Statement.h>
#include <Poco/Data/SessionFactory.h>
#include <Poco/Data/MySQL/Connector.h>
#include <Poco/Data/MySQL/MySQLException.h>
#include <ctime>
#include <Poco/Timezone.h>
using namespace Poco;
using namespace Poco::Data;
using namespace Poco::Data::MySQL;

DbHelpMySQL::DbHelpMySQL( const string& conn )
{
	_conn=conn;
}

bool DbHelpMySQL::PushTicket(Ticket& t )
{
	try
	{
		Poco::Data::Session db(SessionFactory::instance().create(MySQL::Connector::KEY, _conn));
		string szQuery=format("SELECT COUNT(*) FROM tickets	WHERE assistantId='%s'",t.assistantId);
		int count=0;
		db<<szQuery,Poco::Data::into(count),Poco::Data::now;
		t.modify=time(0);
		string dt1=format_time_t_string(t.modify);
		string dt2=format_time_t_string(t.session_validate_date);
		if (0==count)
		{
			Poco::Data::BLOB keyBlob(t.sessionValidationData);
			time_t modify=time(0);
			szQuery="INSERT INTO tickets VALUES(?,?,?,?,?,?,?,?,?,?)";
			db<<szQuery,use(t.assistantId),use(t.x_ace_host),use(t.user_agent),use(t.speechId),use(keyBlob),use(t.expired),use(modify),use(dt1),use(t.session_validate_date),use(dt2),now;
		}
		else
		{
			Poco::Data::BLOB keyBlob(t.sessionValidationData);
			time_t modify=time(0);
			szQuery=format("UPDATE tickets SET x_ace_host=?, user_agent=?,speechId=?,sessionValidationData=?,expired=?,modify=?,modify_date_string=?,session_validate_date=?,session_validate_date_string=? WHERE assistantId='%s'",t.assistantId);
			db<<szQuery,use(t.x_ace_host),use(t.user_agent),use(t.speechId),use(keyBlob),use(t.expired),use(modify),use(dt1),use(t.session_validate_date),use(dt2),now;
		}
		return true;
	}
	catch(MySQLException& e)
	{
		InternalLogInfo("PushTicket:"+e.displayText());
		return false;
	}
	return true;
}

bool DbHelpMySQL::TicketFromAssistantId( const string& assistantId,Ticket& t )
{
	try
	{
		Poco::Data::Session db(SessionFactory::instance().create(MySQL::Connector::KEY, _conn));
		string szQuery=format("SELECT * FROM Tickets WHERE assistantId='%s'",assistantId);
		Poco::Data::Statement stmt=(db<<szQuery,now);
		RecordSet rs(stmt);
		if(rs.rowCount()==0)
			return false;
		int i=0;
		t.assistantId=rs.value<string>(0,i);
		t.x_ace_host=rs.value<string>(1,i);
		t.user_agent=rs.value<string>(2,i);
		t.speechId=rs.value<string>(3,i);
		Poco::Data::BLOB keyBlob=rs.value<Poco::Data::BLOB>(4,i);
		t.sessionValidationData=keyBlob.content();

		t.expired=rs.value<Int32>(5,i);
		t.modify=rs.value<Int64>(6,i);

		t.session_validate_date=rs.value<Int64>(8,i);
	}
	catch(MySQLException& e)
	{
		InternalLogInfo(format("TicketFromAssistantId出现异常:%s",e.displayText()));
		return false;
	}
	return true;
}

vector<Ticket> DbHelpMySQL::GetAllValidTickets()
{
	vector<Ticket> tickets;

	try
	{
		Poco::Data::Session db(SessionFactory::instance().create(MySQL::Connector::KEY,_conn));
		string szQuery=format("SELECT * FROM tickets WHERE expired <= %d",Ticket::EXPIRE_WATER_MARK); 
	
		Poco::Data::Statement stmt=(db << szQuery,now);
		RecordSet rs(stmt);
		size_t rows=rs.rowCount();
		for (size_t i=0;i<rows;i++)
		{
			Ticket t;
			t.assistantId=rs.value<string>(0,i);
			t.x_ace_host=rs.value<string>(1,i);
			t.user_agent=rs.value<string>(2,i);
			t.speechId=rs.value<string>(3,i);
			

			Poco::Data::BLOB keyBlob=rs.value<Poco::Data::BLOB>(4,i);
			t.sessionValidationData=keyBlob.content();

			t.expired=rs.value<Int32>(5,i);
			t.modify=rs.value<Int64>(6,i);

			t.session_validate_date=rs.value<Int64>(8,i);
			tickets.push_back(t);
		}
	}
	catch(MySQLException& e)
	{	
		InternalLogInfo(format("GetAllValidTickets出现了异常:%s",e.displayText()));
	}
	return tickets;
}

vector<string> DbHelpMySQL::GetAllKeys()
{
	vector<string> keys;

	try
	{
		Poco::Data::Session db(SessionFactory::instance().create(MySQL::Connector::KEY,_conn));
		string szQuery="SELECT key_id FROM allkeys"; 

		Poco::Data::Statement stmt=(db << szQuery,now);
		RecordSet rs(stmt);
		size_t rows=rs.rowCount();
		for (size_t i=0;i<rows;i++)
		{
			string tmp=rs.value<string>(0,i);
			keys.push_back(tmp);
		}
	}
	catch(MySQLException& e)
	{	
		InternalLogInfo(format("GetAllTickets出现了异常:%s",e.displayText()));
	}
	return keys;
}

vector<Ticket> DbHelpMySQL::GetAllTickets()
{
	vector<Ticket> tickets;

	try
	{
		Poco::Data::Session db(SessionFactory::instance().create(MySQL::Connector::KEY,_conn));
		string szQuery="SELECT * FROM tickets ORDER BY modify ASC"; 

		Poco::Data::Statement stmt=(db << szQuery,now);
		RecordSet rs(stmt);
		size_t rows=rs.rowCount();
		for (size_t i=0;i<rows;i++)
		{
			Ticket t;
			t.assistantId=rs.value<string>(0,i);
			t.x_ace_host=rs.value<string>(1,i);
			t.user_agent=rs.value<string>(2,i);
			t.speechId=rs.value<string>(3,i);


			Poco::Data::BLOB keyBlob=rs.value<Poco::Data::BLOB>(4,i);
			t.sessionValidationData=keyBlob.content();

			t.expired=rs.value<Int32>(5,i);
			t.modify=rs.value<Int64>(6,i);

			t.session_validate_date=rs.value<Int64>(8,i);
			tickets.push_back(t);
		}
	}
	catch(MySQLException& e)
	{	
		InternalLogInfo(format("GetAllTickets出现了异常:%s",e.displayText()));
	}
	return tickets;
}

int DbHelpMySQL::GetTotalTicketCount()
{
	try
	{
		Poco::Data::Session db(SessionFactory::instance().create(MySQL::Connector::KEY, _conn));
		string szQuery="SELECT COUNT(*) FROM Tickets";
		int count=0;
		db<<szQuery,Poco::Data::into(count),Poco::Data::now;
		return count;
	}
	catch(MySQLException& e)
	{	
		InternalLogInfo(format("GetAllTickets出现了异常:%s",e.displayText()));
		return 0;
	}
}

int DbHelpMySQL::GetExpiredTicketCount()
{
	try
	{
		Poco::Data::Session db(SessionFactory::instance().create(MySQL::Connector::KEY, _conn));
		string szQuery=format("SELECT COUNT(*) FROM Tickets WHERE expired > %d",Ticket::EXPIRE_WATER_MARK);
		int count=0;
		db<<szQuery,Poco::Data::into(count),Poco::Data::now;
		return count;
	}
	catch(MySQLException& e)
	{	
		InternalLogInfo(format("GetAllTickets出现了异常:%s",e.displayText()));
		return 0;
	}
}

bool DbHelpMySQL::CheckKeyFlow( const string& key,const string& ipaddr )
{
	try
	{
		Poco::Data::Session db(SessionFactory::instance().create(MySQL::Connector::KEY, _conn));
		string szQuery=format("SELECT COUNT(*) FROM allkeys WHERE key_id='%s'",key);
		int count=0;
		db<<szQuery,Poco::Data::into(count),Poco::Data::now;
		if(count==0)
			return false;
		szQuery="INSERT INTO acs_logs (key_id,peer_ipaddress,time_stamp,time_stamp_string) VALUES(?,?,?,?)";
		time_t t=time(0);
		string t_str=format_time_t_string(t);
		db<<szQuery,use(key),use(ipaddr),use(t),use(t_str),now;
		return true;
	}
	catch(MySQLException& e)
	{
		InternalLogInfo(format("CheckKeyFlow出现了异常:%s",e.displayText()));
		return false;
	}
}

bool DbHelpMySQL::RemoveTicket( const char* assistantId )
{
	try
	{
		Poco::Data::Session db(SessionFactory::instance().create(MySQL::Connector::KEY, _conn));
		string szQuery=format("DELETE FROM tickets WHERE assistantId='%s'",string(assistantId));
		db<<szQuery,now;
		return true;
	}
	catch(MySQLException& e)
	{
		InternalLogInfo(format("CheckKeyFlow出现了异常:%s",e.displayText()));
		return false;
	}
}

bool DbHelpMySQL::CheckKeyFlow( const char* key,const char* ipaddr )
{
	if(CheckKey())
	{
		string _key=key; 
		string _ipaddr=ipaddr;
		return CheckKeyFlow(_key,_ipaddr);
	}
	else
	{
		return true;
	}
}

vector<key_acl_log> DbHelpMySQL::GetKeyAclDetail( const int& limit/*=-1*/ )
{
	vector<key_acl_log> clist;
	try
	{
		Poco::Data::Session db(SessionFactory::instance().create(MySQL::Connector::KEY, _conn));
		string szQuery="SELECT key_id,hints,COUNT(DISTINCT peer_ipaddress) IP_COUNT from vKeyLogs GROUP BY key_id,hints ORDER BY IP_COUNT DESC,hints ASC";
		if(limit!=-1)
		{
			szQuery.append(format(" LIMIT %d",limit));
		}
		
		Poco::Data::Statement stmt=(db << szQuery,now);
		RecordSet rs(stmt);
		size_t rows=rs.rowCount();
		for (size_t i=0;i<rows;i++)
		{
			key_acl_log log;
			log.key_id=rs.value<string>(0,i);
			log.hints=(int)rs.value<UInt32>(1,i);
			log.ip_count=(int)rs.value<Int64>(2,i);
			clist.push_back(log);
		}
		return clist;
	}
	catch(MySQLException& e)
	{
		InternalLogInfo(format("GetKeyAclDetail出现了异常:%s",e.displayText()));
		return clist;
	}
}
