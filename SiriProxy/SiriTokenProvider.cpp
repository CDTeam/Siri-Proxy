// Copyright (c) 2011,cd-team.org.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
#include "StdAfx.h"
#include <plist/plist++.h>
#include "DbHelpSQL.h"
#include "SiriTokenProvider.h"
#include <Poco/Net/HTTPRequest.h>
#include <Poco/RegularExpression.h>

using namespace Poco::Net;
using namespace Poco;
list<Ticket> SiriTokenProvider::g_tickets;
list<string> SiriTokenProvider::assistant_in_uses;
vector<string> SiriTokenProvider::g_allkeys;
Poco::FastMutex SiriTokenProvider::_mutex_tickets; 
Poco::FastMutex SiriTokenProvider::_mutex_keys; 
extern string g_app_path;

int Ticket::EXPIRE_WATER_MARK=2;
SiriTokenProvider::SiriTokenProvider()
{
	processed=false;
}

void SiriTokenProvider::FreeInstanse( Ptr ptr )
{
	delete ptr;
}

SiriTokenProvider::Ptr SiriTokenProvider::FromAceHeader( const string& header )
{
	SiriTokenProvider::Ptr p=new SiriTokenProvider();
	p->m_http_string=header;
	if(p->m_http_string.find("Assistant(iPhone/iPhone4,1;")!=-1) 
	{
		stringstream ss(p->m_http_string);
		HTTPRequest req;
		req.read(ss);
		if(req.has("X-Ace-Host"))
		{
			p->m_Ticket.x_ace_host=req["X-Ace-Host"];
		}
		if(req.has("User-Agent"))
		{
			p->m_Ticket.user_agent=req["User-Agent"];
		}
		p->iPhone4s=true;
		p->m_Ticket.iPhone4s=true;
		if(!p->CheckHeader())
		{
			delete p;
			return NULL;
		}
	}
	else
	{
		p->m_http_string=iPhone4s_header_tmpl;
		p->iPhone4s=false;
		p->m_Ticket.iPhone4s=false;
		if(!p->CheckHeader())
		{
			delete p;
			return NULL;
		}
		
		stringstream ss(p->m_http_string);
		HTTPRequest req;
		req.read(ss);

		string strAceHost;
		size_t offset=p->m_http_string.find("X-Ace-Host");
		if(offset!=-1)
		{
			size_t n1=p->m_http_string.find(":",offset);
			if(n1==(offset+strlen("X-Ace-Host")))
			{
				size_t n2=p->m_http_string.find("\r\n",n1);
				if(n2>n1)
				{
					string ace_host=p->m_http_string.substr(n1+1,n2-n1);
					p->m_Ticket.x_ace_host=ace_host;
					strAceHost=ace_host;
				}
			}
		}
		if(req.has("X-Ace-Host"))
		{
			strAceHost==req.get("X-Ace-Host");
			if(!strAceHost.empty())
				p->m_Ticket.x_ace_host=strAceHost;
		}

		p->m_Ticket.x_ace_host_tmpl=p->m_Ticket.x_ace_host;

		if(!SiriTokenProvider::GetNextTicket(&p->m_Ticket))
		{
			delete p;
			return NULL;
		}

		p->m_http_string=Poco::replace(p->m_http_string,strAceHost,p->m_Ticket.x_ace_host);
		p->m_http_string=Poco::replace(p->m_http_string,"siri.cd-team.org","guzzoni.apple.com");

	}

	return p;
}

bool SiriTokenProvider::CheckHeader()
{
	return true;
}

bool SiriTokenProvider::GetNextTicket( Ticket* pTicket )
{
	if(pTicket->processed)
		return true;

	FastMutex::ScopedLock lock(_mutex_tickets);
	if(g_tickets.size()==0)
		return false;
	for (list<Ticket>::iterator itr=g_tickets.begin();itr!=g_tickets.end();itr++)
	{
		if(!itr->used && !itr->IsExpired())
		{
			itr->used=true;//使用标志置为true

			pTicket->assistantId=itr->assistantId;
			pTicket->sessionValidationData=itr->sessionValidationData;
			pTicket->session_validate_date=itr->session_validate_date;
			pTicket->speechId=itr->speechId;
			pTicket->user_agent=itr->user_agent;
			pTicket->x_ace_host=itr->x_ace_host;
			pTicket->modify=itr->modify;
			pTicket->expired=itr->expired;
			pTicket->used=itr->used;

			if(std::find(assistant_in_uses.begin(),assistant_in_uses.end(),itr->assistantId)==assistant_in_uses.end())
			{
				assistant_in_uses.push_back(itr->assistantId);
			}

			pTicket->processed=true;
			return true;
		}
	}
	return false;
}

void SiriTokenProvider::PushBackTicket( const Ticket& t,bool bLock)
{
	if(t.IsExpired())
		return;
	if(bLock)
	{
		FastMutex::ScopedLock lock(_mutex_tickets);
		list<string>::iterator it=std::find(assistant_in_uses.begin(),assistant_in_uses.end(),t.assistantId);
		list<Ticket>::iterator itr=std::find(g_tickets.begin(),g_tickets.end(),t);
		if((itr==g_tickets.end()) && (it==assistant_in_uses.end()))
		{
			g_tickets.push_back(t);
		}
	}
	else
	{
		list<string>::iterator it=std::find(assistant_in_uses.begin(),assistant_in_uses.end(),t.assistantId);
		list<Ticket>::iterator itr=std::find(g_tickets.begin(),g_tickets.end(),t);
		if((itr==g_tickets.end()) && (it==assistant_in_uses.end()))
		{
			g_tickets.push_back(t);
		}
	}
}


void SiriTokenProvider::RemoveTicket( const char* assistantId )
{
	FastMutex::ScopedLock lock(_mutex_tickets);
	Ticket t;
	t.assistantId=assistantId;
	list<Ticket>::iterator itr=std::find(g_tickets.begin(),g_tickets.end(),t);
	if(itr!=g_tickets.end())
	{
		g_tickets.erase(itr);
	}

	DbHelpSQL::Current()->RemoveTicket(assistantId);
}

void SiriTokenProvider::RecycleTicket( const Ticket& t,bool bLock)
{
	if(bLock)
	{
		FastMutex::ScopedLock lock(_mutex_tickets);
		list<string>::iterator it=std::find(assistant_in_uses.begin(),assistant_in_uses.end(),t.assistantId);
		list<Ticket>::iterator itr=std::find(g_tickets.begin(),g_tickets.end(),t);
		if(itr!=g_tickets.end())
		{
			itr->used=false;//使用标志置为false
		}
		if(it!=assistant_in_uses.end())
		{
			assistant_in_uses.erase(it);
		}

	}
	else
	{
		list<string>::iterator it=std::find(assistant_in_uses.begin(),assistant_in_uses.end(),t.assistantId);
		list<Ticket>::iterator itr=std::find(g_tickets.begin(),g_tickets.end(),t);
		if(itr!=g_tickets.end())
		{
			itr->used=false;//使用标志置为false
		}
		if(it!=assistant_in_uses.end())
		{
			assistant_in_uses.erase(it);
		}
	}
}

void SiriTokenProvider::InitCache()
{
	vector<Ticket> rs =DbHelpSQL::Current()->GetAllValidTickets();
	g_tickets.clear();
	for (vector<Ticket>::iterator itr=rs.begin();itr!=rs.end();itr++)
	{
		g_tickets.push_back(*itr);
	}

	g_allkeys=DbHelpSQL::Current()->GetAllKeys();
}

void SiriTokenProvider::iPhone4sRefreshTicket()
{
	if(m_Ticket.IsValid())
	{
		{
			DbHelpSQL::Current()->PushTicket(m_Ticket);
		}
		{
			FastMutex::ScopedLock lock(_mutex_tickets);
			list<Ticket>::iterator itr=std::find(g_tickets.begin(),g_tickets.end(),m_Ticket);
			if(itr!=g_tickets.end())
			{
				itr->assistantId=m_Ticket.assistantId;
				itr->expired=0;
				itr->modify=m_Ticket.modify;
				itr->session_validate_date=m_Ticket.session_validate_date;
				itr->sessionValidationData=m_Ticket.sessionValidationData;
				itr->speechId=m_Ticket.speechId;
				itr->user_agent=m_Ticket.user_agent;
				itr->x_ace_host=m_Ticket.x_ace_host;
			}
			else
			{
				SiriTokenProvider::PushBackTicket(m_Ticket,false);
			}
		}
	}
}

void SiriTokenProvider::iPhone4RefreshTicket()
{
	if(m_Ticket.IsValid())
	{
		{
			DbHelpSQL::Current()->PushTicket(m_Ticket);
		}
		{
			FastMutex::ScopedLock lock(_mutex_tickets);
			list<Ticket>::iterator itr=std::find(g_tickets.begin(),g_tickets.end(),m_Ticket);
			if(itr!=g_tickets.end())
			{
				if(m_Ticket.IsExpired())
				{
					g_tickets.erase(itr);
				}
				else
				{
					itr->assistantId=m_Ticket.assistantId;
					itr->expired=m_Ticket.expired;
					itr->modify=m_Ticket.modify;
					itr->session_validate_date=m_Ticket.session_validate_date;
					itr->sessionValidationData=m_Ticket.sessionValidationData;
					itr->speechId=m_Ticket.speechId;
					itr->user_agent=m_Ticket.user_agent;
					itr->x_ace_host=m_Ticket.x_ace_host;
				}
			}
		}
	}
}

int SiriTokenProvider::GetExpiredTicketCount()
{
	return DbHelpSQL::Current()->GetExpiredTicketCount();
}

int SiriTokenProvider::GetTotalTicketCount()
{
	return DbHelpSQL::Current()->GetTotalTicketCount();
}

vector<Ticket> SiriTokenProvider::GetAllValidTickets()
{
	return DbHelpSQL::Current()->GetAllValidTickets();
}

int SiriTokenProvider::GetCacheTicketCount()
{
	FastMutex::ScopedLock lock(_mutex_tickets);
	return g_tickets.size();
}

int SiriTokenProvider::GetTickeInUseCount()
{
	FastMutex::ScopedLock lock(_mutex_tickets);
	return assistant_in_uses.size();
}

bool SiriTokenProvider::IsKeyAuthoriz( const char* key )
{
	if(DbHelpSQL::Current()->CheckKey())
	{
		FastMutex::ScopedLock lock(_mutex_keys);
		bool br=find(g_allkeys.begin(),g_allkeys.end(),string(key))!=g_allkeys.end();
		return br;
	}
	else
	{
		return true;
	}
}

#ifdef _SAVE_PLIST
void SiriTokenProvider::SavePlistXML( const char* plistData,const size_t dataLen,bool bPush )
{
	plist_t plist=NULL;
	plist_from_bin(plistData,dataLen,&plist);

	if(plist)
	{
		uint32_t xLen=0;
		char* xData=NULL;

		plist_to_xml(plist,&xData,&xLen);
		
		if(bPush)
		{
			static int index=0;
			FileOutputStream fs(format("e:\\plist_push\\%d.txt",++index));
			fs.write(xData,xLen);
			fs.flush();
		}
		else
		{
			static int index=0;
			FileOutputStream fs(format("e:\\plist_pull\\%d.txt",++index));
			fs.write(xData,xLen);
			fs.flush();
		}
		
		PlistFreeMem(xData);

		plist_free(plist);
	}
}
#endif // _SAVE_PLIST