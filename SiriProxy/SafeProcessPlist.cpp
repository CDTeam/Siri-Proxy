// Copyright (c) 2011,cd-team.org.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
#include "StdAfx.h"
#include "SafeProcessPlist.h"
#include "SiriTokenProvider.h"
#include "DbHelpSQL.h"

extern string x_assistant_id;
#define EXCEPTION_CODE 1

const char* SESSION_EPRIED_KEY="SessionValidationFailed";
const char* COMMAND_FAILED_KEY="CommandFailed";
const char* ASSISTANT_LOADED_KEY="AssistantLoaded";
const char* ASSISTANT_CREATE_KEY="AssistantCreated";

HOST_PLIST_RESULT check_host_plist_result(const char* plistData,const size_t dataLen,Ticket* pTicket)
{
	__try{
		HOST_PLIST_RESULT hr=RESULT_OK;
		plist_t plist=NULL;
		plist_from_bin(plistData,dataLen,&plist);
		plist_type type=plist_get_node_type((plist_t)plist);
		if(type!=PLIST_DICT)
		{
			plist_free(plist);
			return RESULT_OK;
		}

		plist_dict_iter itr=NULL;
		plist_dict_new_iter(plist,&itr);

		char* key=NULL;
		plist_t valNode=NULL;
		plist_dict_next_item(plist,itr,&key,&valNode);
		if(stricmp(key,"class")==0)
		{
			PlistFreeMem(key);
			char *str=NULL;
			plist_get_string_val(valNode,&str);

			if(stricmp(str,SESSION_EPRIED_KEY)==0)
			{//session已经过期
				PlistFreeMem(str);
				hr=RESULT_SESSION_EPRIED;
			}
			else if(stricmp(str,COMMAND_FAILED_KEY)==0)
			{//命令失败
				PlistFreeMem(str);
				hr=RESULT_COMMAND_FAILED;
			}
			else if(stricmp(str,ASSISTANT_LOADED_KEY)==0)
			{
				PlistFreeMem(str);
				hr=RESULT_ASSISTANT_LOADED;
			}
			else if(stricmp(str,ASSISTANT_CREATE_KEY)==0)
			{
				hr=RESULT_ASSISTANT_CREATE;
				pTicket->iPhone4s_Create_Key=true;
				PlistFreeMem(str);
				plist_dict_next_item(plist,itr,&key,&valNode);
				while (valNode!=NULL)
				{
					if(stricmp(key,"properties")==0)
					{
						type=plist_get_node_type(valNode);
						if(PLIST_DICT==type)
						{
							plist_dict_iter xitr=NULL;
							plist_dict_new_iter(valNode,&xitr);

							char* subKey=NULL;
							plist_t node=NULL;
							plist_dict_next_item(valNode,xitr,&subKey,&node);
							while(node!=NULL)
							{	
								if(stricmp(subKey,"assistantId")==0)
								{
									plist_get_string_val(node,&str);
									pTicket->assistantId.clear();
									pTicket->assistantId.assign(str);
									PlistFreeMem(str);
									str=NULL;
								}
								else if(stricmp(subKey,"speechId")==0)
								{
									plist_get_string_val(node,&str);
									pTicket->speechId.clear();
									pTicket->speechId.assign(str);
									PlistFreeMem(str);
									str=NULL;
								}
								PlistFreeMem(subKey);
								plist_dict_next_item(valNode,xitr,&subKey,&node);
							}
							PlistFreeMem(xitr);
						}
						break;
					}
					PlistFreeMem(key);
					plist_dict_next_item(plist,itr,&key,&valNode);
				}
			}
		}
		PlistFreeMem(itr);
		plist_free(plist);
		return hr;
	}__except(EXCEPTION_CODE){
		return RESULT_OK;
	}
}

FIX_PLIST_RESULT fix_plist_xml( const char* plistData,const size_t& dataLen,vector<char>&fixOut ,Ticket* pTicket,bool iphone4s,bool& processed,char** pplistXML)
{
	if(processed)
	{
		return FIX_RESULT_SUCCESS;
	}

	plist_t plist=NULL;

	__try{
		plist_from_bin(plistData,dataLen,&plist);
	}__except(EXCEPTION_CODE){
		return FIX_RESULT_FAIL;
	}

	FIX_PLIST_RESULT success=FIX_RESULT_FAIL;
	bool _processed=processed;
	if(iphone4s)
	{
		success=process_iphone4s_plist(plist,processed,pTicket,pplistXML);
		
	}
	else
	{//如果是iPhone4
		success=process_iphone4_plist(plist,processed,pTicket,pplistXML);
	}
	
	char* plistbin=NULL;
	uint32_t dwLen=0;

	__try{
		plist_to_bin(plist,&plistbin,&dwLen);
		plist_free(plist);
	}__except(EXCEPTION_CODE){
		return FIX_RESULT_FAIL;
	}

	if(dwLen&&plistbin)
	{
		size_t sz=fixOut.size();
		fixOut.resize(sz+dwLen);
		memcpy(&fixOut[sz],plistbin,dwLen);
		PlistFreeMem(plistbin);
	}

	return success;
}

FIX_PLIST_RESULT process_iphone4s_plist( plist_t plist,bool& processed,Ticket* pTicket,char** pplistXML)
{
	__try
	{
		#pragma region //主体
		uint32_t xLen=0;
		char* xData=NULL;
		char* plistXML=NULL;
		if(pplistXML!=NULL)
		{
			__try{
				plist_to_xml(plist,&xData,&xLen);
				plistXML=new char[xLen];
				memcpy(plistXML,xData,xLen);
				*pplistXML=plistXML;
				PlistFreeMem(xData);
			}__except(EXCEPTION_CODE){
				return FIX_RESULT_FAIL;
			}
		}

		if(processed)
			return FIX_RESULT_SUCCESS;
		plist_type type=plist_get_node_type((plist_t)plist);
		if(type!=PLIST_DICT)
			return FIX_RESULT_SUCCESS;

		plist_dict_iter itr=NULL;
		plist_dict_new_iter(plist,&itr);

		char* key=NULL;
		plist_t valNode=NULL;
		plist_dict_next_item(plist,itr,&key,&valNode);
		if(stricmp(key,"class")==0)
		{
			PlistFreeMem(key);
			char *str=NULL;
			plist_get_string_val(valNode,&str);

			if(stricmp(str,"LoadAssistant")==0)
			{//这是LoadAssistant,一般是第一个包
				PlistFreeMem(str);
				plist_dict_next_item(plist,itr,&key,&valNode);
				while (valNode!=NULL)
				{
					if(stricmp(key,"properties")==0)
					{
						type=plist_get_node_type(valNode);
						if(PLIST_DICT==type)
						{
							plist_dict_iter xitr=NULL;
							plist_dict_new_iter(valNode,&xitr);

							char* subKey=NULL;
							plist_t node=NULL;
							plist_dict_next_item(valNode,xitr,&subKey,&node);
							while(node!=NULL)
							{
								if(stricmp(subKey,"speechId")==0)
								{
									plist_get_string_val(node,&str);
									pTicket->speechId.clear();
									pTicket->speechId.assign(str);
									PlistFreeMem(str);
									str=NULL;
								}
								else if(stricmp(subKey,"assistantId")==0)
								{
									plist_get_string_val(node,&str);
									pTicket->assistantId.clear();
									pTicket->assistantId.assign(str);
									PlistFreeMem(str);
									str=NULL;
								}
								else if(stricmp(subKey,"sessionValidationData")==0)
								{
									uint64_t llen=0;
									plist_get_data_val(node,&str,&llen);
									size_t cpyLen=(size_t)llen;
									if(cpyLen>0)
									{
										pTicket->sessionValidationData.clear();
										pTicket->sessionValidationData.resize(cpyLen);
										memcpy(&pTicket->sessionValidationData[0],str,cpyLen);
										PlistFreeMem(str);
										str=NULL;
									}
								}
								PlistFreeMem(subKey);
								plist_dict_next_item(valNode,xitr,&subKey,&node);
							}

							PlistFreeMem(xitr);
						}
						break;
					}
					PlistFreeMem(key);
					plist_dict_next_item(plist,itr,&key,&valNode);
				}
				processed=true;
			}
			else if (stricmp(str,"CreateAssistant")==0)
			{
				PlistFreeMem(str);
				plist_dict_next_item(plist,itr,&key,&valNode);
				while (valNode!=NULL)
				{
					if(stricmp(key,"properties")==0)
					{
						type=plist_get_node_type(valNode);
						if(PLIST_DICT==type)
						{
							plist_dict_iter xitr=NULL;
							plist_dict_new_iter(valNode,&xitr);

							char* subKey=NULL;
							plist_t node=NULL;
							plist_dict_next_item(valNode,xitr,&subKey,&node);
							while(node!=NULL)
							{
								if(stricmp(subKey,"validationData")==0)
								{
									uint64_t llen=0;
									plist_get_data_val(node,&str,&llen);
									size_t cpyLen=(size_t)llen;
									if(cpyLen>0)
									{
										pTicket->sessionValidationData.clear();
										pTicket->sessionValidationData.resize(cpyLen);
										memcpy(&pTicket->sessionValidationData[0],str,cpyLen);
										PlistFreeMem(str);
										str=NULL;
									}
								}
								PlistFreeMem(subKey);
								plist_dict_next_item(valNode,xitr,&subKey,&node);
							}
							PlistFreeMem(xitr);
						}
						break;
					}
					PlistFreeMem(key);
					plist_dict_next_item(plist,itr,&key,&valNode);
				}
				SiriTokenProvider::RemoveTicket(pTicket->assistantId.c_str());
			}
			else if(stricmp(str,"DestroyAssistant")==0)
			{
				PlistFreeMem(str);
				plist_dict_next_item(plist,itr,&key,&valNode);
				while (valNode!=NULL)
				{
					if(stricmp(key,"properties")==0)
					{
						type=plist_get_node_type(valNode);
						if(PLIST_DICT==type)
						{
							plist_dict_iter xitr=NULL;
							plist_dict_new_iter(valNode,&xitr);

							char* subKey=NULL;
							plist_t node=NULL;
							plist_dict_next_item(valNode,xitr,&subKey,&node);
							while(node!=NULL)
							{
								if(stricmp(subKey,"assistantId")==0)
								{
									plist_get_string_val(node,&str);
									SiriTokenProvider::RemoveTicket(str);
									PlistFreeMem(str);
									str=NULL;
								}
								PlistFreeMem(subKey);
								plist_dict_next_item(valNode,xitr,&subKey,&node);
							}
							PlistFreeMem(xitr);
						}
						break;
					}
					PlistFreeMem(key);
					plist_dict_next_item(plist,itr,&key,&valNode);
				}
			}
		}
		PlistFreeMem(itr);

		if(pplistXML!=NULL)
		{
			xData=NULL;
			delete[] plistXML;
			__try{
				plist_to_xml(plist,&xData,&xLen);
				plistXML=new char[xLen];
				memcpy(plistXML,xData,xLen);
				*pplistXML=plistXML;
				PlistFreeMem(xData);
			}__except(EXCEPTION_CODE){
				return FIX_RESULT_FAIL;
			}
		}
		return FIX_RESULT_SUCCESS;
		#pragma endregion
	}
	__except(EXCEPTION_CODE)
	{
		return FIX_RESULT_FAIL;
	}
}

FIX_PLIST_RESULT process_iphone4_plist( plist_t plist,bool& processed,Ticket* pTicket,char** pplistXML)
{
	__try
	{
		FIX_PLIST_RESULT code=FIX_RESULT_SUCCESS;
#pragma region //主体
		uint32_t xLen=0;
		char* xData=NULL;
		char* plistXML=NULL;
		if(pplistXML!=NULL)
		{
			__try{
				plist_to_xml(plist,&xData,&xLen);
				plistXML=new char[xLen];
				memcpy(plistXML,xData,xLen);
				*pplistXML=plistXML;
				PlistFreeMem(xData);
			}__except(EXCEPTION_CODE){
				return FIX_RESULT_FAIL;
			}
		}

		if(processed)
			return FIX_RESULT_SUCCESS;
		plist_type type=plist_get_node_type((plist_t)plist);
		if(type!=PLIST_DICT)
			return FIX_RESULT_SUCCESS;

		plist_dict_iter itr=NULL;
		plist_dict_new_iter(plist,&itr);

		char* key=NULL;
		plist_t valNode=NULL;
		plist_dict_next_item(plist,itr,&key,&valNode);
		if(stricmp(key,"class")==0)
		{
			PlistFreeMem(key);
			char *str=NULL;
			plist_get_string_val(valNode,&str);

			if(stricmp(str,"LoadAssistant")==0)
			{//这是LoadAssistant,一般是第一个包
				PlistFreeMem(str);
				plist_dict_next_item(plist,itr,&key,&valNode);

				while (valNode!=NULL)
				{
					if(stricmp(key,"properties")==0)
					{
						type=plist_get_node_type(valNode);
						if(PLIST_DICT==type)
						{
							bool isKeyOK=false;
							char* subKey=NULL;
							plist_t node=NULL;
							plist_dict_iter xitr=NULL;
							plist_dict_new_iter(valNode,&xitr);
							plist_dict_next_item(valNode,xitr,&subKey,&node);
							while(node!=NULL)
							{
								if(stricmp(subKey,"assistantId")==0)
								{
									char* tmp=NULL;
									plist_get_string_val(node,&tmp);

									if(SiriTokenProvider::IsKeyAuthoriz(tmp))
									{
										isKeyOK=true;
										code= FIX_RESULT_SUCCESS;
									}
									else
									{
										code=FIX_RESULT_INVALID_KEY;
									}
									PlistFreeMem(tmp);
								}
								PlistFreeMem(subKey);
								plist_dict_next_item(valNode,xitr,&subKey,&node);
							}
							PlistFreeMem(xitr);

							if (isKeyOK &&(FIX_RESULT_SUCCESS==code))
							{
								xitr=NULL;
								plist_dict_new_iter(valNode,&xitr);
								plist_dict_next_item(valNode,xitr,&subKey,&node);
								while(node!=NULL)
								{
									if(stricmp(subKey,"speechId")==0)
									{
										plist_set_string_val(node,pTicket->speechId.c_str());
									}
									else if(stricmp(subKey,"assistantId")==0)
									{
										char* tmp=NULL;
										plist_get_string_val(node,&tmp);

										DbHelpSQL::Current()->CheckKeyFlow(tmp,pTicket->ip_address.c_str());
										plist_set_string_val(node,pTicket->assistantId.c_str());

										PlistFreeMem(tmp);
									}
									else if(stricmp(subKey,"sessionValidationData")==0)
									{
										size_t dwSessionDataLen=pTicket->sessionValidationData.size();
										if(dwSessionDataLen>0)
										{
											plist_set_data_val(node,&pTicket->sessionValidationData[0],dwSessionDataLen);
										}
									}
									PlistFreeMem(subKey);
									plist_dict_next_item(valNode,xitr,&subKey,&node);
								}
								PlistFreeMem(xitr);
							}
						}
						break;
					}
					PlistFreeMem(key);
					plist_dict_next_item(plist,itr,&key,&valNode);
				}
				processed=true;
			}
		}
		PlistFreeMem(itr);

		if(pplistXML!=NULL)
		{
			xData=NULL;
			delete[] plistXML;
			__try{
				plist_to_xml(plist,&xData,&xLen);
				plistXML=new char[xLen];
				memcpy(plistXML,xData,xLen);
				*pplistXML=plistXML;
				PlistFreeMem(xData);
			}__except(EXCEPTION_CODE){
				return FIX_RESULT_FAIL;
			}
		}

		return code;
#pragma endregion
	}
	__except(EXCEPTION_CODE)
	{
		return FIX_RESULT_FAIL;
	}
}

char* plist_bin_to_xml( const char* plistData,const size_t& dataLen )
{
	char* p=NULL;
	__try{
		plist_t plist=NULL;
		plist_from_bin(plistData,dataLen,&plist);

		if(plist)
		{
			uint32_t xLen=0;
			char* xData=NULL;

			plist_to_xml(plist,&xData,&xLen);
			if(xData!=NULL && xLen)
			{
				p=new char[xLen+1];
				memcpy(p,xData,xLen);
				p[xLen]='\0';
				PlistFreeMem(xData);
			}
			plist_free(plist);
		}
		return p;
	}__except(EXCEPTION_CODE){
		return p;
	}
}

bool plist_xml_to_bin( const char* plistxml,char** ppfixdata,size_t& nLen)
{
	char* p=NULL;
	__try{
		plist_t plist=NULL;
		plist_from_xml(plistxml,strlen(plistxml),&plist);

		if(plist)
		{
			char* xData=NULL;
			plist_to_bin(plist,&xData,&nLen);
			if(xData!=NULL && nLen)
			{
				p=new char[nLen];
				memcpy(p,xData,nLen);
				PlistFreeMem(xData);
				*ppfixdata=p;
			}
			plist_free(plist);
		}
		else
		{
			return false;
		}
		return true;
	}__except(EXCEPTION_CODE){
		return false;
	}
}
