// Copyright (c) 2011,cd-team.org.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
#include "SiriTcpSvr.h"
#include "SiriClientConnection.h"
#include "CatchTokenClientConnection.h"

SiriTcpSvr* SiriTcpSvr::m_sigleton_ip4=NULL;
SiriTcpSvr* SiriTcpSvr::m_sigleton_ip4s=NULL;
#define MAX_THREADS_COUNT 2048L
#define MIN_THREADS_COUNT 8

SiriTcpSvr::SiriTcpSvr( TCPServerConnectionFactory::Ptr pFactory, Poco::ThreadPool& threadPool, const ServerSocket& socket, TCPServerParams::Ptr pParams /*= 0*/ )
	:TCPServer(pFactory,threadPool,socket,pParams)
{
	ssock=socket;
	iPhone4s=false;
}

SiriTcpSvr::~SiriTcpSvr(void)
{
	ssock.close();
	delete pX509Certificate;
}

SiriTcpSvr* SiriTcpSvr::iPhone4Server()
{
	if(NULL==m_sigleton_ip4)
	{
		Application& app=Application::instance();
		InternalLogInfo("读取iPhone4服务器配置文件..");
		
		unsigned short port = (unsigned short) app.config().getInt("server.iphone4.port", 443);
		string host=app.config().getString("server.iphone4.IPv4v6");

		SocketAddress addr(host,port);
		SecureServerSocket ssock(addr,128);
		ssock.listen();

		int maxThreads=app.config().getInt("server.iphone4.threadPool.maxThreads",256);
		int minThreads=app.config().getInt("server.iphone4.threadPool.minThreads",2);
		
		TCPServerParams::Ptr prams=new TCPServerParams();
		//ToDo:配置服务器参数
		prams->setMaxQueued(128);
		prams->setMaxThreads(maxThreads);
		
		static ThreadPool pools(minThreads,maxThreads);
		m_sigleton_ip4=new SiriTcpSvr(new TCPServerConnectionFactoryImpl<SiriClientConnection>(),pools,ssock,prams);
		m_sigleton_ip4->pathCA=app.config().getString("openSSL.server.caConfig");
		m_sigleton_ip4->pathKey=app.config().getString("openSSL.server.privateKeyFile");
		m_sigleton_ip4->iPhone4s=false;
		m_sigleton_ip4->pX509Certificate=new X509Certificate(m_sigleton_ip4->pathCA);
	}
	return m_sigleton_ip4;
}


SiriTcpSvr* SiriTcpSvr::iPhone4sServer()
{
	if(NULL==m_sigleton_ip4s)
	{
		Application& app=Application::instance();
		InternalLogInfo("读取iPhone4s服务器配置文件..");

		unsigned short port = (unsigned short) app.config().getInt("server.iphone4s.port", 443);
		string host=app.config().getString("server.iphone4s.IPv4v6");
		
		string keyFile=app.config().getString("server.iphone4s.openssl.privateKeyFile");
		string caFile=app.config().getString("server.iphone4s.openssl.caConfig");
		Context::Ptr ctx=new Context(Context::SERVER_USE,keyFile,caFile,/*caLocation*/"",Context::VERIFY_NONE);

		SocketAddress addr(host,port);
		SecureServerSocket ssock(addr,128,ctx);
	
		ssock.listen();

		int maxThreads=app.config().getInt("server.iphone4s.threadPool.maxThreads",256);
		int minThreads=app.config().getInt("server.iphone4s.threadPool.minThreads",2);

		TCPServerParams::Ptr prams=new TCPServerParams();
		//ToDo:配置服务器参数
		prams->setMaxQueued(128);
		prams->setMaxThreads(maxThreads);

		static ThreadPool pools(minThreads,maxThreads);
		m_sigleton_ip4s=new SiriTcpSvr(new TCPServerConnectionFactoryImpl<CatchTokenClientConnection>(),pools,ssock,prams);
		
		m_sigleton_ip4s->pathCA=caFile;
		m_sigleton_ip4s->pathKey=keyFile;
		m_sigleton_ip4s->iPhone4s=true;
		m_sigleton_ip4s->pX509Certificate=new X509Certificate(caFile);
	}
	return m_sigleton_ip4s;
}

void SiriTcpSvr::start()
{
	X509Certificate cer(pathCA);
	Context::Ptr ctx=ssock.context();
	address=ssock.address().toString();
	const TCPServerParams&  prams=this->params();
	startTime=time(0);
	ostringstream ms;
	ms<<(iPhone4s ? "ipHone4s代理Tcp服务器已经启动\n":"ipHone4代理Tcp服务器已经启动\n" );
	ms<<("服务器在"+format_time_t_string(startTime)+"启动成功!\n");
	ms<<"-----------------------------详细信息-----------------------------\n";
	ms<<"绑定地址:"<<address<<"\n";
	ms<<"SSL验证模式:"<<ctx->verificationMode()<<"\n";
	ms<<"颁发给:"<<cer.commonName()<<"\n";
	ms<<"证书颁发者:"<<cer.issuerName()<<"\n";
	ms<<"证书主题:"<<cer.subjectName()<<"\n";
	ms<<"证书过期时间:"<<DateTimeFormatter::format(cer.expiresOn(),"%Y-%n-%d %H-%M-%S")<<"\n";
	ms<<"证书起始时间:"<<DateTimeFormatter::format(cer.validFrom(),"%Y-%n-%d %H-%M-%S")<<"\n";
	ms<<"服务器最大线程数:"<<prams.getMaxThreads()<<"\n";
	ms<<"服务器最大连接队列:"<<prams.getMaxQueued()<<"\n";
	ms<<"------------------------------------------------------------------\n\n";
	InternalLogInfo(ms.str());
	return TCPServer::start();
}
