// Copyright (c) 2011,cd-team.org.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.IO;
using System.Runtime.InteropServices;

namespace SiriProxy.Plugins.Interface4Net
{
    public static class PluginLoader
    {
        public static IntPtr EnumAvailablePlugins(ref UInt32 size)
        {
            size=0;
            string plugindir = AppDomain.CurrentDomain.BaseDirectory + @"plugins.net\";
            if (!Directory.Exists(plugindir))
            {
                Directory.CreateDirectory(plugindir);
            }
            string[] files = Directory.GetFiles(plugindir,"*.dll");
            List<IntPtr> clist = new List<IntPtr>();
            foreach (string file in files)
            {
                try
                {
                    Assembly asm=Assembly.LoadFile(file);
                    if (null == asm)
                        continue;
                    Attribute attr = Attribute.GetCustomAttribute(asm, typeof(SiriPluginModuleAttribute));
                    if (null == attr)
                    {//这说明该程序集没有被SiriPluginModuleAttribute所标记，那么，我们认为他不是插件模块的主入口(有可能是插件引用的程序集)，忽略它
                       
                        continue;
                    }

                    SiriPluginModuleAttribute xattr = (SiriPluginModuleAttribute)attr;
                    
                    Type[] types = asm.GetTypes();
                    foreach (Type t in types)
                    {
                        if (typeof(IPluginServiceMain).IsAssignableFrom(t))
                        {//查找所有实现了IPluginServiceMain的类型class
                            if (t.IsClass)
                            {
                                object obj = Activator.CreateInstance(t, new object[0]);
                                IPluginServiceMain plugin = (IPluginServiceMain)obj;
                                PluginInfo info=plugin.PluginServiceMain();
                                if (info.CommandText!=null && info.InitPluginModule!=null && info.OnCommandCall!=null)
                                {
                                    IntPtr p = Marshal.AllocHGlobal(Marshal.SizeOf(info));
                                    Marshal.StructureToPtr(info, p, true);
                                    clist.Add(p);
                                }
                            }
                        }
                    }
                }
                catch (Exception)
                {//捕捉异常，因为文件有可能不是.net的程序集
                    continue;
                }
            }

            size=(UInt32)clist.Count;
            if (size > 0)
            {
                unsafe
                {
                    IntPtr px = Marshal.AllocHGlobal(IntPtr.Size * clist.Count);
                    void** pp = (void**)px.ToPointer();
                    for (int i = 0; i < size; i++)
                    {
                        pp[i] = clist[i].ToPointer();
                    }
                    return px;//new IntPtr((void*)pp);
                }
            }
            return IntPtr.Zero;
        }

        public static void PluginInfoArrayFree(IntPtr pp)
        {
            Marshal.FreeHGlobal(pp);
        }
    }
}
