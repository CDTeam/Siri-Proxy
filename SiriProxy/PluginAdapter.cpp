// Copyright (c) 2011,cd-team.org.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
#include "PluginAdapter.h"
#include <Poco/String.h>
#include <Poco/Exception.h>
#include <Poco/DirectoryIterator.h>
#include <Poco/RegularExpression.h>
#include <Poco/File.h>
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>

#include "StdAfx.h"
#include "SiriClientServiceHandler.h"
using namespace Poco;
extern bool __stdcall RegisterPluginInfo(const PluginInfo* info);

static RegularExpression ___regex_text("‘.+’",RegularExpression::RE_CASELESS,false);

PluginMgr* PluginMgr::__sigleton=0x00;

#define FORCE_RESULT(exp,ret) if(!exp) return ret
#define FORCAE_NULL_RESULT(exp,ret) if(0==exp) return ret
#define GOTO_DEFAULT_IF_NULL(obj) if(0==obj) goto DEFAULT

PluginInfo**  __stdcall EnumAvailablePlugins(size_t* pArraySize);
void __stdcall PluginInfoArrayFree(PluginInfo** pp);

FuncEnumAvailablePlugins pfnEnumAvailablePlugins=NULL;
FuncPluginInfoArrayFree  pfnPluginInfoArrayFree=NULL;

void __stdcall PluginInfoArrayFree(PluginInfo** pp)
{
	delete[] pp;
}

PluginInfo**  __stdcall EnumAvailablePlugins(size_t* pArraySize)
{
	*pArraySize=0;

	string scPath;
	char path[1024];
	int n = GetModuleFileNameA(0, path, sizeof(path));
	scPath = path;
	scPath=scPath.substr(0,scPath.find_last_of('\\')+1);
	scPath+="plugins";
	
	DWORD   dwFileAttr   = GetFileAttributesA(scPath.c_str()); 
	if( dwFileAttr == INVALID_FILE_ATTRIBUTES ||   (dwFileAttr&FILE_ATTRIBUTE_DIRECTORY)!= FILE_ATTRIBUTE_DIRECTORY) 
	{ 
		CreateDirectoryA(scPath.c_str(),NULL);
	}

	DirectoryIterator sitr(scPath);
	PluginInfo** pps=NULL;
	vector<PluginInfo*> vx;
	while(sitr!=DirectoryIterator())
	{
		try
		{
			if(sitr->isFile())
			{
				string s=sitr->path();
				Path pc(s);
				string ext=pc.getExtension();
				if (stricmp(ext.c_str(),"dll")==0)
				{
					HMODULE hMod=LoadLibraryA(s.c_str());
					if (hMod)
					{
						FnPluginInitMain pfn=(FnPluginInitMain)GetProcAddress(hMod,"PluginInitMain");
						if(pfn!=0)
						{
							PluginInfo* info=pfn();
							if(info!=NULL && info->CommandText!=NULL && info->OnCommandCall!=NULL)
							{
								vx.push_back(info);
							}
							else
							{
								FreeLibrary(hMod);
							}
						}
						else
						{
							FreeLibrary(hMod);
						}
					}
				}
			}
		}
		catch(Poco::Exception&){}
		sitr++;
	}

	if(vx.size())
	{
		PluginInfo** p=new PluginInfo*[vx.size()];
		for (int i=0;i<vx.size();i++)
		{
			p[i]=vx[i];
		}
		*pArraySize=vx.size();
		return p;
	}
	return NULL;
}

PluginMgr* PluginMgr::Current()
{
	if(0x00==__sigleton)
		__sigleton=new PluginMgr();
	return __sigleton;
}

void PluginMgr::LoadPlugin()
{
	size_t size=0;
	PluginInfo** pplugins= EnumAvailablePlugins(&size);
	if(size)
	{
		for (int i=0;i<size;i++)
		{
			PluginInfo* info=pplugins[i];
			RegisterPluginInfo(info);
			info->PluginInfoFree(info);
		}
		PluginInfoArrayFree(pplugins);
	}

	if(pfnEnumAvailablePlugins)
	{
		pplugins=pfnEnumAvailablePlugins(&size);

		if (size)
		{
			for (int i=0;i<size;i++)
			{
				PluginInfo* info=pplugins[i];
				RegisterPluginInfo(info);
				info->PluginInfoFree(info);
			}

			if(pfnPluginInfoArrayFree)
			{
				pfnPluginInfoArrayFree(pplugins);
			}
		}
	}
}

PluginMgr::PluginMgr(){	
}


void PluginMgr::FilterPlistBin(char* plistData,const size_t& dataLen,void* context )
{
	string cls;
	Guard<PList::Node> guad;
	SiriClientServiceHandler* svc=(SiriClientServiceHandler*)(context);
	plist_t plist=NULL;
	plist_from_bin(plistData,dataLen,&plist);
	if(NULL==plist)
		goto DEFAULT;
	PList::Node* root=PList::Node::FromPlist(plist);
	guad.SetDataPtr(root);
	if(root->GetType()!=PLIST_DICT){
		goto DEFAULT;
	}
	PList::Dictionary* dict=dynamic_cast<PList::Dictionary*>(root);
	PList::Dictionary* rootDict=dict;
	PList::String* clsNode=dynamic_cast<PList::String*>(dict->Find("class")->second);
	if(NULL==clsNode){
		goto DEFAULT;
	}
	cls=clsNode->GetValue();
	if("AddViews"==cls)
	{
		dict=dynamic_cast<PList::Dictionary*>(dict->Find("properties")->second);
		GOTO_DEFAULT_IF_NULL(dict);
		PList::Array* arr=dynamic_cast<PList::Array*>(dict->Find("views")->second);
		if(NULL==arr || arr->GetSize()==0) 
			goto DEFAULT;
		PList::Dictionary* subDict=dynamic_cast<PList::Dictionary*>((*arr)[0]);
		GOTO_DEFAULT_IF_NULL(subDict);
		clsNode=dynamic_cast<PList::String*>(subDict->Find("class")->second);
		if(NULL==clsNode || clsNode->GetValue()!="AssistantUtteranceView") 
			goto DEFAULT;
		PList::Dictionary* xdict=dynamic_cast<PList::Dictionary*>(subDict->Find("properties")->second);
		GOTO_DEFAULT_IF_NULL(xdict);
		PList::String* key=dynamic_cast<PList::String*>(xdict->Find("dialogIdentifier")->second);
		GOTO_DEFAULT_IF_NULL(key);
		string indentifier=key->GetValue();
		size_t pos=indentifier.find("Misc#answer");
		size_t len=strlen("Misc#answer");

		string sendText;
		PList::String* textNode=NULL;
		PList::String* speakNode=NULL;
		if(pos==0&& (indentifier.size()>len))//if start with 'Misc#answer'
		{
			sendText=indentifier.substr(len);
			textNode=dynamic_cast<PList::String*>(xdict->Find("text")->second);
			speakNode=dynamic_cast<PList::String*>(xdict->Find("speakableText")->second);
		}
		else if(indentifier=="Common#unknownIntent")
		{
			key=dynamic_cast<PList::String*>(xdict->Find("text")->second);
			textNode=key;
			speakNode=dynamic_cast<PList::String*>(xdict->Find("speakableText")->second);
			string text=key->GetValue();
			wstring wpattern=L"‘.+’";
			string pattern=Utf16ToUtf8(wpattern);
			RegularExpression::Match mtch;
			RegularExpression regex(pattern,RegularExpression::RE_CASELESS);
			int c= regex.match(text,0,mtch);
			if(c!=0)
			{
				string str=text.substr(mtch.offset,mtch.length);
				wstring xstr=UTF8ToUTF16(str);
				if(xstr.length()>2)
				{
					xstr=xstr.substr(1,xstr.length()-2);
					sendText=Utf16ToUtf8(xstr);
				}
			}
		}

		vector<PluginInfoInternal> plus=FindPluginMatch(sendText);
		if(textNode && speakNode && plus.size())
		{
			string aceId=dynamic_cast<PList::String*>(rootDict->Find("aceId")->second)->GetValue();
			string refId=dynamic_cast<PList::String*>(rootDict->Find("refId")->second)->GetValue();

			PlistPackageArgs* arg=new PlistPackageArgs();
			memset(arg,0,sizeof(PlistPackageArgs));
			strcpy(&arg->aceId[0],aceId.c_str());
			strcpy(&arg->refId[0],refId.c_str());

			size_t xLen =sendText.size()+1;
			arg->sendText=new char[xLen];
			strcpy(arg->sendText,sendText.c_str());

			key=dynamic_cast<PList::String*>(xdict->Find("text")->second);
			string resp=key->GetValue();
			xLen=resp.size()+1;
			arg->responseText=new char[xLen];
			strcpy(arg->responseText,resp.c_str());

			for (vector<PluginInfoInternal>::iterator itr=plus.begin();itr!=plus.end();itr++)
			{
				CommandCallResult* pResult=itr->OnCommandCall(arg);
				if(RESULT_PLIST_XML==pResult->type)
				{
					plist_t plistnew=NULL;
					plist_from_xml(pResult->result_text,strlen(pResult->result_text)+1,&plist);
					if(plistnew)
					{
						char* xData=NULL;
						uint32_t xLen=0;
						plist_to_bin(plistnew,&xData,&xLen);
						if(xData&&xLen)
						{
							if(!svc->WriteSocketPlistBin(xData,xLen,false))
							{
								plist_free(plistnew);
								PlistFreeMem(xData);
								svc->Finalize();
								break;
							}
							PlistFreeMem(xData);
						}
						plist_free(plistnew);
					}
					else
					{
						Poco::Logger& log=Poco::Util::Application::instance().logger();
						string msg=Poco::format("Id为%s的插件返回的plist的xml格式有错,请去除该插件,并检查..",itr->PluginId);
						log.information(msg);
					}
				}
				else
				{//CommandCallResult::RESULT_TEXT==pResult->type
					textNode->SetValue(pResult->result_text);
					speakNode->SetValue(pResult->result_text);
					
					char* xData=NULL;
					uint32_t xLen=0;
					plist_to_bin(plist,&xData,&xLen);
					if(xData&&xLen)
					{
						if(!svc->WriteSocketPlistBin(xData,xLen,false))
						{
							PlistFreeMem(xData);
							svc->Finalize();
							break;
						}
						PlistFreeMem(xData);
					}
				}

				if (pResult->FreeCommandCallResult!=NULL)
				{
					pResult->FreeCommandCallResult(pResult);
				}
			}

			delete[] arg->sendText;
			delete[] arg->responseText;
			delete arg;
			return;
		}
	}

DEFAULT:
	svc->WriteSocketPlistBin(plistData,dataLen,false);
}

vector<PluginInfoInternal> PluginMgr::GetPlugins()
{
	FastMutex::ScopedLock locker(_mutex);
	return plugins;
}

void PluginMgr::PushbackPluginInternal( const PluginInfoInternal& info )
{
	FastMutex::ScopedLock locker(_mutex);
	plugins.push_back(info);
}

vector<PluginInfoInternal> PluginMgr::FindPluginMatch( const string& text )
{
	vector<PluginInfoInternal> ret;
	FastMutex::ScopedLock locker(_mutex);
	for (vector<PluginInfoInternal>::iterator itr=plugins.begin();plugins.end()!=itr;itr++)
	{
		if(!itr->CommandMatchPattern.empty())
		{//优先使用命令的正则匹配
			RegularExpression regex(itr->CommandMatchPattern,RegularExpression::RE_CASELESS);
			RegularExpression::Match mt;
			if(regex.match(text,mt))
			{
				ret.push_back(*itr);
				continue;
			}
		}

		string xtext=Poco::toLower(text);
		if (xtext.find(itr->CommandText)!=(~0))
		{
			ret.push_back(*itr);
		}
	}
	return ret;
}

extern bool __stdcall RegisterPluginInfo(const PluginInfo* info)
{
	if(0x00==info)
		return false;
	bool has=false;
	vector<PluginInfoInternal> plugins=PluginMgr::Current()->GetPlugins();
	for (vector<PluginInfoInternal>::iterator itr=plugins.begin();itr!=plugins.end();itr++)
	{
		string s1=itr->PluginId;
		
		string s2=&info->PluginId[0];

		if(s1==s2)
		{
			has=true;
			break;
		}
	}
	if(!has)
	{
		PluginInfoInternal info_;
		if(info->CommandMatchPattern)
		{
			info_.CommandMatchPattern=info->CommandMatchPattern;
		}
		
		if(info->CommandText)
		{
			info_.CommandText=info->CommandText;
		}
		info_.InitPluginModule=info->InitPluginModule;
		info_.OnCommandCall=info->OnCommandCall;
		info_.PluginId=&info->PluginId[0];
		info_.PluginName=info->PluginName;
		info_.UnInitPluginModule=info->UnInitPluginModule;
		PluginMgr::Current()->PushbackPluginInternal(info_);
		info->InitPluginModule();
		return true;
	}
	return false;
}