// Copyright (c) 2011,cd-team.org.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
#include "PackageProcessor.h"
using namespace Poco;


PackageProcessor::PackageProcessor(IPackageEventHandler* pNotify,bool push)
{
	bPush=push;
	state=STATE_NONE;
	nextLen_state_none=0;
	nextLen_plist=0;
	nextLen_state_0x03_0x04=0;
	nextLen_plist_t=0;
	n_plist_next_size=0;
	pEventNotify=pNotify;
}

bool PackageProcessor::ProcessBuffer( const char* data,size_t dataSize,size_t offset )
{
	if(offset==dataSize)
		return true;
	if(offset>dataSize)
	{
		Poco::Logger& logger=Poco::Util::Application::instance().logger();
		string msg=Poco::format("索引超出界限,数组长度:%d,下一个偏移量:%d",(int)dataSize,(int)offset);
		logger.warning(msg);
		return false;
	}
	//static int offset=0;//定义区块偏移量
	char* cache=NULL;
	switch(state)
	{
	case STATE_NONE:
		{
			if(nextLen_state_none!=0)
			{
				size_t sz=bin_state_none.size();
				size_t seek=offset+nextLen_state_none;
				if(seek>dataSize)
				{//悲剧,下一个偏移量已经超过data的长度了，读取可读取的，期待下次读取
					size_t ableLen=dataSize-offset;
					if(ableLen>0)
					{
						bin_state_none.resize(sz+ableLen);
						memcpy(&bin_state_none[sz],data+offset,ableLen);
						offset+=ableLen;
						nextLen_state_none-=ableLen;
					}
					return true;
				}
				else
				{//下一个偏移量没有超过data的长度,拷贝数据
					bin_state_none.resize(sz+nextLen_state_none);
					if(nextLen_state_none!=0)
					{
						memcpy(&bin_state_none[sz],data+offset,nextLen_state_none);
						offset+=nextLen_state_none;
					}

					cache=new char[bin_state_none.size()];
					memcpy(cache,&bin_state_none[0],3);
					bin_state_none.clear();
					nextLen_state_none=0;

					if(memcmp(cache,header_0x020000,SIZE_HEAD_BLOCK)==0)
					{
						delete[] cache;
						state=STATE_0x02_GET_NUM;
						return ProcessBuffer(data,dataSize,offset);
					}
					else if(memcmp(cache,header_0x030000,SIZE_HEAD_BLOCK)==0 || memcmp(cache,header_0x040000,SIZE_HEAD_BLOCK)==0)
					{
						delete[] cache;
						state=STATE_0x03_0x04;
						return ProcessBuffer(data,dataSize,offset);
					}
					Poco::Logger& logger=Poco::Util::Application::instance().logger();
					string msg=Poco::format("遇到未知的起始标志:%c,%c,%c",cache[0],cache[1],cache[2]);
					logger.warning(msg);
					delete[] cache;
					return false;
				}
			}
			else
			{
				bin_state_none.clear();
				size_t seek=offset+SIZE_HEAD_BLOCK;
				nextLen_state_none=SIZE_HEAD_BLOCK;
				if(seek>dataSize)
				{//数据不足
					size_t ableLen=dataSize-offset;
					if(ableLen>0)
					{
						bin_state_none.resize(ableLen);
						memcpy(&bin_state_none[0],data+offset,ableLen);
						offset+=ableLen;
						nextLen_state_none-=ableLen;
					}
					return true;
				}
				else
				{

					vector<unsigned char> vx(3);
					memcpy(&vx[0],data+offset,SIZE_HEAD_BLOCK);

					cache=new char[SIZE_HEAD_BLOCK];
					memcpy(cache,data+offset,SIZE_HEAD_BLOCK);
					offset+=SIZE_HEAD_BLOCK;
					nextLen_state_none=0;

					if(memcmp(cache,header_0x020000,SIZE_HEAD_BLOCK)==0)
					{
						delete[] cache;
						state=STATE_0x02_GET_NUM;
						return ProcessBuffer(data,dataSize,offset);
					}
					else if(memcmp(cache,header_0x030000,SIZE_HEAD_BLOCK)==0 || memcmp(cache,header_0x040000,SIZE_HEAD_BLOCK)==0)
					{
						delete[] cache;
						state=STATE_0x03_0x04;
						return ProcessBuffer(data,dataSize,offset);
					}

					Poco::Logger& logger=Poco::Util::Application::instance().logger();
					string msg=Poco::format("遇到未知的起始标志:%c%c%c",cache[0],cache[1],cache[2]);
					logger.warning(msg);
					delete[] cache;
					return false;
				}
			}
		}
		break;
	case STATE_0x02_GET_NUM:
		{
			if(nextLen_plist_t!=0)
			{
				size_t seek=offset+nextLen_plist_t;
				size_t sz_t=plistbin_t.size();
				if(seek>dataSize)
				{//------------------------------------------------
					size_t ableLen=dataSize-offset;
					if(ableLen>0)
					{
						plistbin_t.resize(sz_t+ableLen);
						memcpy(&plistbin_t[sz_t],data+offset,ableLen);
						offset+=ableLen;
						nextLen_plist_t-=ableLen;
					}
					return true;
				}
				else
				{//------------------------------------------------
					plistbin_t.resize(sz_t+nextLen_plist_t);
					if(nextLen_plist_t!=0)
					{
						memcpy(&plistbin_t[sz_t],data+offset,nextLen_plist_t);
						offset+=nextLen_plist_t;
					}

					memcpy(&n_plist_next_size,&plistbin_t[0],2);
					ConvertEndian16(&n_plist_next_size);
					nextLen_plist_t=0;	
					state=STATE_0x020000;
					return ProcessBuffer(data,dataSize,offset);
				}
			}
			else
			{
				plistbin_t.clear();
				size_t _seek=offset+2;
				nextLen_plist_t=2;//!!!
				if(_seek>dataSize)
				{
					size_t ableLen=dataSize-offset;
					if(ableLen>0)
					{
						plistbin_t.resize(ableLen);
						memcpy(&plistbin_t[0],data+offset,ableLen);
						offset+=ableLen;
						nextLen_plist_t-=ableLen;
					}
					return true;
				}
				else
				{
					memcpy(&n_plist_next_size,data+offset,2);
					offset+=2;
					ConvertEndian16(&n_plist_next_size);
					nextLen_plist_t=0;
					state=STATE_0x020000;
					return ProcessBuffer(data,dataSize,offset);
				}
			}
		}
		break;
	case STATE_0x020000:
		{
			if(nextLen_plist!=0)
			{//说明上次STATE_0x020000状态时plist的内容没有读完
				size_t sz=plistbin.size();
				size_t seek=offset+nextLen_plist;
				if(seek>dataSize)
				{//悲剧,下一个偏移量已经超过data的长度了，读取可读取的，期待下次读取
					//!!!nextLen_plist=seek-dataSize;
					size_t ableLen=dataSize-offset;
					if(ableLen>0)
					{
						plistbin.resize(sz+ableLen);
						memcpy(&plistbin[sz],data+offset,ableLen);
						offset+=ableLen;
						nextLen_plist-=ableLen;
					}
					return true;
				}
				else
				{//下一个偏移量没有超过data的长度,拷贝数据
					plistbin.resize(sz+nextLen_plist);
					if(nextLen_plist!=0)
					{
						memcpy(&plistbin[sz],data+offset,nextLen_plist);
						offset+=nextLen_plist;
					}

					pEventNotify->OnPlistPackage(&plistbin[0],plistbin.size(),bPush);

					//清理plist缓冲区
					plistbin.clear();
					nextLen_plist=0;

					//状态置为STATE_NONE
					state=STATE_NONE;
					return ProcessBuffer(data,dataSize,offset);
				}
			}
			else
			{
				plistbin.clear();
				short plistlen=n_plist_next_size;

				/*memcpy(&plistlen,data+offset,2);
				offset+=2;
				ConvertEndian16(&plistlen);*/

				size_t seek=offset+plistlen;
				nextLen_plist=plistlen;//!!!
				if(seek>dataSize)
				{//下一个偏移量已经超过data的长度了，读取可读取的，期待下次读取
					//!!!nextLen_plist=seek-dataSize;
					size_t ableLen=dataSize-offset;
					if(ableLen>0)
					{
						plistbin.resize(ableLen);
						memcpy(&plistbin[0],data+offset,ableLen);
						offset+=ableLen;
						nextLen_plist-=ableLen;
					}
					return true;
				}
				else
				{//下一个偏移量没有超过data的长度,拷贝数据
					plistbin.resize(plistlen);
					if(plistlen!=0)
					{
						memcpy(&plistbin[0],data+offset,plistlen);
						offset+=plistlen;
					}

					//ToDo:处理plist数据
					pEventNotify->OnPlistPackage(&plistbin[0],plistbin.size(),bPush);

					//清理plist缓冲区
					plistbin.clear();
					nextLen_plist=0;

					//状态置为STATE_NONE
					state=STATE_NONE;
					return ProcessBuffer(data,dataSize,offset);
				}
			}
		}
		break;
	case STATE_0x03_0x04:
		{
			if(nextLen_state_0x03_0x04!=0)
			{
				size_t sz=bin_state_0x03_0x04.size();
				size_t seek=offset+nextLen_state_0x03_0x04;
				if(seek>dataSize)
				{//悲剧,下一个偏移量已经超过data的长度了，读取可读取的，期待下次读取
					//!!!nextLen_state_0x030000=seek-dataSize;
					size_t ableLen=dataSize-offset;
					if(ableLen>0)
					{
						bin_state_0x03_0x04.resize(sz+ableLen);
						memcpy(&bin_state_0x03_0x04[sz],data+offset,ableLen);
						offset+=ableLen;
						nextLen_state_0x03_0x04-=ableLen;
					}
					return true;
				}
				else
				{//下一个偏移量没有超过data的长度,拷贝数据
					bin_state_0x03_0x04.resize(sz+nextLen_state_0x03_0x04);
					if(nextLen_state_0x03_0x04!=0)
					{
						memcpy(&bin_state_0x03_0x04[sz],data+offset,nextLen_state_0x03_0x04);
						offset+=nextLen_state_0x03_0x04;
					}

					cache=new char[bin_state_0x03_0x04.size()];
					memcpy(cache,&bin_state_0x03_0x04[0],SIZE_SHORT);
					bin_state_0x03_0x04.clear();
					nextLen_state_0x03_0x04=0;

					short sequnce=0;
					memcpy(&sequnce,cache,SIZE_SHORT);
					offset+=SIZE_SHORT;
					ConvertEndian16(&sequnce);

					pEventNotify->OnPingPackage(cache,SIZE_SHORT,bPush);
					

					delete[] cache;
					state=STATE_NONE;

					return ProcessBuffer(data,dataSize,offset);
				}
			}
			else
			{
				bin_state_0x03_0x04.clear();
				size_t seek=offset+SIZE_SHORT;//接下来一个短整形
				nextLen_state_0x03_0x04=SIZE_SHORT;
				if(seek>dataSize)
				{//数据不足,等待下次接收
					//!!!nextLen_state_0x030000=seek-dataSize;
					size_t ableLen=dataSize-offset;
					if(ableLen>0)
					{
						bin_state_0x03_0x04.resize(ableLen);
						memcpy(&bin_state_0x03_0x04[0],data+offset,ableLen);
						offset+=ableLen;
						nextLen_state_0x03_0x04-=ableLen;
					}
					return true;
				}
				else
				{
					short sequnce=0;

					cache=new char[SIZE_SHORT];
					memcpy(cache,data+offset,SIZE_SHORT);

					memcpy(&sequnce,data+offset,SIZE_SHORT);
					offset+=SIZE_SHORT;
					ConvertEndian16(&sequnce);

					pEventNotify->OnPingPackage(cache,SIZE_SHORT,bPush);
					
					delete[] cache;

					nextLen_state_0x03_0x04=0;
					state=STATE_NONE;
					return ProcessBuffer(data,dataSize,offset);
				}
			}
		}
		break;
	}
	return true;
}
